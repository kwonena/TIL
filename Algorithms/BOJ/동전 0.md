### **문제 조건과 설명**

준규가 가지고 있는 동전은 총 N종류이고, 각각의 동전을 매우 많이 가지고 있다.

동전을 적절히 사용해서 그 가치의 합을 K로 만들려고 한다. 이때 필요한 동전 개수의 최솟값을 구하는 프로그램을 작성하시오.

---

### **Input**

첫째 줄에 N과 K가 주어진다. (1 ≤ N ≤ 10, 1 ≤ K ≤ 100,000,000)

둘째 줄부터 N개의 줄에 동전의 가치 Ai가 오름차순으로 주어진다. (1 ≤ Ai ≤ 1,000,000, A1 \= 1, i ≥ 2인 경우에 Ai는 Ai-1의 배수)

---

### **Output**

첫째 줄에 K원을 만드는데 필요한 동전 개수의 최솟값을 출력한다.

---

### **스스로 생각하기**

시간 초과가 뜬 코드라 pypy3로 제출했습니다😵‍💫

첫 번째 줄에 동전의 가치 n과 합 k원을 입력받습니다.

동전의 가치를 저장할 리스트로 money를 만들어,

반복문을 통해 동전의 가치를 저장합니다.

이제, k원을 만드는데 필요한 동전 개수를 구할 것입니다.

동전 개수 coin을 0으로 초기화하고

수월한 계산을 위해 money를 reverse 함수로 거꾸로 저장합니다.

그러면 현재 money는 \[50000, 10000, 5000, 1000,...\]으로 변환됩니다.

money의 인덱스 값을 계산하기 위한 i를 0으로 초기화한 후,

k가 0보다 클 동안 while 반복문을 돌려줍니다.

money 리스트를 돌며 k보다 작은 최댓값을 조건문으로 걸어줍니다.

reverse로 함수를 변환시킨 이유는 이것 때문입니다.

예시대로 k가 4200원이라면,

처음으로 조건문에 걸린 money의 값은 1000일 것입니다.

(인덱스 i의 값은 3이 됩니다.)

그러면 while 반복문을 통해

k가 해당 money 값보다 클 동안 돌려줍니다.

작다면 k에서 해당 money 값을 빼주며

동전의 개수를 1씩 증가시킵니다.

여기서 k가 4200원이라면 money의 값이 1000이 되고,

4200 - 1000 - 1000 - 1000 - 1000 = 200원 < money = 1000 이기 때문에

코인의 개수가 4가 됩니다.

money \[3\]의 값이 현재 k == 200보다 크기 때문에

while 반복문을 나와 i를 1 증가시켜줍니다.

계산을 하다 k가 0보다 작아질 때

최상단의 while 반복문을 빠져나오며 동전의 개수를 출력해줍니다.

---

### **소스코드**

```
n, k = map(int, input().split())

money = []  # 동전의 가치 리스트

# 동전의 가치
for _ in range(n):
    m = int(input())
    money.append(m)

# k원을 만드는데 필요한 동전 개수
coin = 0  # 동전의 개수
money.reverse()

i = 0

while k > 0:
    if money[i] <= k:
        while money[i] <= k:
            k -= money[i]
            coin += 1
    i += 1

print(coin)
```
