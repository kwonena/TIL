### **문제 조건과 설명**

한 개의 회의실이 있는데 이를 사용하고자 하는 N개의 회의에 대하 여 회의실 사용표를 만들려고 한다. 각 회의 I에 대해 시작시간과 끝나는 시간이 주어져 있고, 각 회의가 겹치지 않게 하면서 회의실을 사용할 수 있는 회의의 최대 개수를 찾아보자. 단, 회의는 한번 시작하면 중간에 중단될 수 없으며 한 회의가 끝나는 것과 동시에 다음 회의가 시작될 수 있다. 회의의 시작시간과 끝나는 시간이 같을 수도 있다. 이 경우에는 시작하자마자 끝나는 것으로 생각하면 된다.

---

### **Input**

첫째 줄에 회의의 수 N(1 ≤ N ≤ 100,000)이 주어진다. 둘째 줄부터 N+1 줄까지 각 회의의 정보가 주어지는데 이것은 공백을 사이에 두고 회의의 시작시간과 끝나는 시간이 주어진다. 시작 시간과 끝나는 시간은 231\-1보다 작거나 같은 자연수 또는 0이다.

---

### **Output**

첫째 줄에 최대 사용할 수 있는 회의의 최대 개수를 출력한다.

---

### **스스로 생각하기**

끝나는 시간이 가장 빠를수록 회의의 최대 개수를 늘릴 수 있겠다 생각해서

끝나는 시간을 기준으로 정렬해준 뒤,

가장 빨리 끝나는 시간을 기점으로 계산해주겠습니다.

n으로 회의의 수를 입력 받고

빈 배열 time에 n개만큼의 시작 시간과 끝나는 시간을 이차원배열로 입력 받습니다.

time의 모든 요소들은

시작 시간과 끝나는 시간으로 이루어져 있기 때문에

시작 시간은 0번째, 끝나는 시간은 1번째 인덱스를 갖게 됩니다.

람다를 이용해 끝나는 시간으로 먼저 정렬한 후,

끝나는 시간이 중복될 때를 위해

시작 시간도 같이 정렬해줍니다.

회의의 개수를 저장할 변수로 cnt를 1로 지정하고,

끝나는 시간을 저장할 변수로 current를 첫번째 항의 끝나는 시간으로 지정합니다.

끝나는 시간이 이미 첫번째 항에서 나왔기 때문에

cnt를 1로 지정해주는 것입니다.

반복문을 통해

current보다 시작 시간이 크거나 같다면

해당 항의 끝나는 시간을 current에 저장해주며

cnt를 1 증가시킵니다.

마지막으로 반복문이 끝나면 cnt를 출력해줍니다.

---

### **소스코드**

```
import sys
input = sys.stdin.readline

n = int(input())  # 회의의 수

time = []

# 회의의 정보 입력
for i in range(n):
    start, end = map(int, input().split())
    time.append([start, end])

# 끝나는 시간을 기준으로 정렬
# 끝나는 시간이 같을 경우 시작 시간을 기준으로 정렬
time.sort(key=lambda x: (x[1], x[0]))

cnt = 1
current = time[0][1]

# 최대 회의 개수 구하기
for i in range(1, n):
    if current <= time[i][0]:
        current = time[i][1]
        cnt += 1

print(cnt)
```
